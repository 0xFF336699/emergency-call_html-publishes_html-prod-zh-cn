<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>跌倒与摇一摇 - Canvas 动画演示</title>
  <style>
    :root { --bg:#0b0f14; --panel:#121821; --text:#d9e1ea; --muted:#8aa1b4; --accent:#4cc9f0; --accent2:#f72585; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; background: var(--bg); color: var(--text); }
    .app { max-width: 980px; margin: 24px auto; padding: 0 16px; }
    .title { font-weight: 700; font-size: 22px; letter-spacing: .3px; margin-bottom: 12px; }
    .tabs { display: flex; gap: 8px; background: var(--panel); border-radius: 14px; padding: 6px; position: sticky; top: 0; z-index: 10; }
    .tab { appearance: none; border: 0; background: transparent; color: var(--muted); padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .tab.active { background: linear-gradient(180deg, #1a2230, #151b24); color: var(--text); box-shadow: 0 6px 16px rgba(0,0,0,.35) inset, 0 1px 0 rgba(255,255,255,.05); }
    .panel { background: var(--panel); border: 1px solid #1f2834; border-radius: 16px; margin-top: 12px; padding: 14px; box-shadow: 0 10px 24px rgba(0,0,0,.3); }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    canvas { width: 100%; max-width: 960px; height: auto; border-radius: 12px; background: radial-gradient(1200px 600px at 50% -300px, rgba(76,201,240,.08), transparent 70%),
              linear-gradient(180deg, #101723, #0f141c); outline: 1px solid #1b2430; }
    .controls { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; align-items: center; }
    .btn { border: 1px solid #223044; background: #121a26; color: var(--text); padding: 8px 12px; border-radius: 10px; cursor: pointer; font-weight: 600; }
    .btn:hover { background: #0f1722; }
    .field { display: inline-flex; gap: 8px; align-items: center; padding: 6px 10px; border: 1px solid #1f2b3c; border-radius: 10px; }
    .field input[type="range"] { width: 160px; }
    .hint { color: var(--muted); font-size: 12px; }
    .badge { display:inline-flex; align-items:center; gap:6px; font-size:12px; padding:4px 8px; border-radius:999px; background:#152233; border:1px solid #1f2d40; }
    .legend { display:flex; gap:12px; flex-wrap:wrap; margin-top:6px; }
    .legend > span { font-size:12px; color: var(--muted); }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#0e141d; border:1px solid #1f2b3c; padding:2px 6px; border-radius:6px; font-size:12px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="title">跌倒/摇一摇 —— Canvas 动画演示</div>
    <div class="tabs" role="tablist">
      <button class="tab active" role="tab" aria-selected="true" id="tab-fall">跌倒演示</button>
      <button class="tab" role="tab" aria-selected="false" id="tab-shake">摇一摇演示</button>
    </div>

    <!-- 跌倒面板 -->
    <section class="panel" id="panel-fall">
      <div class="row">
        <div class="badge">人体简化模型 · 旋转/重心/接触反弹</div>
      </div>
      <canvas id="fallCanvas" width="960" height="540" aria-label="跌倒动画画布"></canvas>
      <div class="controls">
        <button class="btn" id="playFall">播放</button>
        <button class="btn" id="replayFall">重播</button>
        <label class="field">速度
          <input type="range" id="speedFall" min="0.5" max="2.0" step="0.1" value="1" />
          <span id="speedFallVal">1.0x</span>
        </label>
        <label class="field"><input type="checkbox" id="toggleGrid" /> 显示地面/辅助线</label>
      </div>
      <div class="legend">
        <span>交互：<span class="kbd">空格</span> 播放/暂停，<span class="kbd">R</span> 重播</span>
        <span class="hint">注：此为示意动画，用于 UI 讨论与用户教育，不代表真实生物力学。</span>
      </div>
    </section>

    <!-- 摇一摇面板 -->
    <section class="panel" id="panel-shake" hidden>
      <div class="row">
        <div class="badge">手机装置示意 · 左右抖动累积计数</div>
      </div>
      <canvas id="shakeCanvas" width="960" height="540" aria-label="摇一摇动画画布"></canvas>
      <div class="controls">
        <button class="btn" id="playShake">开始</button>
        <button class="btn" id="stopShake">停止</button>
        <label class="field">灵敏度
          <input type="range" id="shakeSensitivity" min="0.2" max="2.0" step="0.1" value="1" />
          <span id="shakeSensitivityVal">1.0</span>
        </label>
        <span class="hint">自动抖动演示，可替换为真实加速度数据。</span>
      </div>
    </section>
  </div>

  <script>
  // --- 工具与通用 ---
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  function resizeForDPR(canvas) {
    const { width, height } = canvas;
    canvas.width = Math.round(width * DPR);
    canvas.height = Math.round(height * DPR);
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
    const ctx = canvas.getContext('2d');
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    return ctx;
  }
  function lerp(a, b, t) { return a + (b - a) * t; }
  function easeInCubic(t){ return t*t*t; }
  function easeOutCubic(t){ return 1- Math.pow(1-t, 3); }
  function easeInOutCubic(t){ return t < .5 ? 4*t*t*t : 1 - Math.pow(-2*t + 2, 3)/2; }

  // --- Tabs ---
  const tabFall = document.getElementById('tab-fall');
  const tabShake = document.getElementById('tab-shake');
  const panelFall = document.getElementById('panel-fall');
  const panelShake = document.getElementById('panel-shake');
  tabFall.addEventListener('click', () => {
    tabFall.classList.add('active'); tabFall.setAttribute('aria-selected','true');
    tabShake.classList.remove('active'); tabShake.setAttribute('aria-selected','false');
    panelFall.hidden = false; panelShake.hidden = true;
  });
  tabShake.addEventListener('click', () => {
    tabShake.classList.add('active'); tabShake.setAttribute('aria-selected','true');
    tabFall.classList.remove('active'); tabFall.setAttribute('aria-selected','false');
    panelShake.hidden = false; panelFall.hidden = true;
  });

  // ===================== 跌倒动画 =====================
  (function initFall(){
    const canvas = document.getElementById('fallCanvas');
    const ctx = resizeForDPR(canvas);
    const W = canvas.clientWidth, H = canvas.clientHeight;

    // 地面线位置（像素）
    const groundY = H - 80;

    // 人体简化：以髋部为旋转枢轴，整体旋转加位移
    const person = {
      x: W*0.35, // 髋部x
      y: groundY - 140, // 髋部y（站立时的高度）
      rot: 0, // 旋转角（度）
      vx: 0, vy: 0, // 位移速度（用于落地后微小反弹）
      width: 28,
      height: 120,
      headR: 18
    };

    // 时间轴（秒）
    const timeline = [
      { name:'sway',   d: 0.5 },  // 轻微摇晃
      { name:'tilt',   d: 0.35 }, // 失去平衡（转到 ~20°）
      { name:'fall',   d: 0.8  }, // 旋转坠落到地面（~90°）
      { name:'impact', d: 0.15 }, // 接触闪烁
      { name:'rest',   d: 0.7  }  // 静止
    ];
    const totalDur = timeline.reduce((s, x) => s + x.d, 0);

    let running = false, t0 = 0, speed = 1.0, showGrid = false, phaseIndex = 0, phaseElapsed = 0;

    // UI 绑定
    const playBtn = document.getElementById('playFall');
    const replayBtn = document.getElementById('replayFall');
    const speedInput = document.getElementById('speedFall');
    const speedVal = document.getElementById('speedFallVal');
    const toggleGrid = document.getElementById('toggleGrid');

    function resetModel(){
      person.x = W*0.35;
      person.y = groundY - 140;
      person.rot = 0;
      person.vx = 0; person.vy = 0;
      phaseIndex = 0; phaseElapsed = 0; t0 = performance.now();
    }

    function play(){ running = true; t0 = performance.now(); raf(); }
    function pause(){ running = false; }

    playBtn.addEventListener('click', () => { running ? pause() : play(); playBtn.textContent = running ? '暂停' : '播放'; });
    replayBtn.addEventListener('click', () => { resetModel(); running = true; playBtn.textContent = '暂停'; });
    speedInput.addEventListener('input', () => { speed = parseFloat(speedInput.value); speedVal.textContent = speed.toFixed(1)+ 'x'; });
    toggleGrid.addEventListener('change', () => { showGrid = toggleGrid.checked; });
    window.addEventListener('keydown', (e)=>{
      if(e.code === 'Space'){ e.preventDefault(); playBtn.click(); }
      if(e.code === 'KeyR'){ e.preventDefault(); replayBtn.click(); }
    });

    // 绘制人体（stick+简化躯干）
    function drawPerson(ctx, x, y, rotDeg){
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotDeg * Math.PI/180);
      // 躯干
      const w = person.width, h = person.height;
      const r = 10;
      ctx.fillStyle = '#a7c4ff';
      roundRect(ctx, -w/2, -h, w, h, r);
      ctx.fill();
      // 头部
      ctx.beginPath();
      ctx.arc(0, -h- person.headR-4, person.headR, 0, Math.PI*2);
      ctx.fillStyle = '#e5f0ff';
      ctx.fill();
      // 手臂与腿（简线）
      ctx.strokeStyle = '#93b6ff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      // 肩膀位置
      const shoulderY = -h + 26;
      // 手臂
      ctx.moveTo(0, shoulderY);
      ctx.lineTo(-28, shoulderY + 18);
      ctx.moveTo(0, shoulderY);
      ctx.lineTo(28, shoulderY + 18);
      // 腿，从髋部
      ctx.moveTo(0, 0);
      ctx.lineTo(-20, 28);
      ctx.moveTo(0, 0);
      ctx.lineTo(22, 30);
      ctx.stroke();
      ctx.restore();

      // 影子
      const shadowW = 90, shadowH = 12;
      const px = x + Math.cos(rotDeg*Math.PI/180)*0; // 简化：影子位置基本在髋部下方
      const py = groundY + 4;
      const alpha = 0.25 + 0.35*Math.min(1, Math.abs(rotDeg)/90);
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#000';
      ellipse(ctx, px, py, shadowW, shadowH);
      ctx.fill();
      ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
    }
    function ellipse(ctx, cx, cy, w, h){
      ctx.save(); ctx.translate(cx, cy); ctx.scale(w/2, h/2); ctx.beginPath(); ctx.arc(0,0,1,0,Math.PI*2); ctx.restore();
    }

    function drawBackground(){
      // 地面
      ctx.save();
      ctx.strokeStyle = '#1e2b3a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, groundY + 0.5);
      ctx.lineTo(W, groundY + 0.5);
      ctx.stroke();

      if(showGrid){
        ctx.globalAlpha = .5;
        ctx.setLineDash([6,6]);
        // 髋部初始位置虚线
        ctx.beginPath(); ctx.moveTo(person.x + .5, 0); ctx.lineTo(person.x + .5, H); ctx.stroke();
        // 头顶高度（站立）
        ctx.beginPath(); ctx.moveTo(0, person.y - person.height - person.headR - 4 + .5); ctx.lineTo(W, person.y - person.height - person.headR - 4 + .5); ctx.stroke();
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }

    function clear(){
      ctx.clearRect(0,0,W,H);
    }

    function integrate(dt){
      // 简单物理：落地后微反弹（只在 impact 后）
      if(phaseIndex >= 3){
        person.y += person.vy * dt;
        // 向地面靠拢
        const targetY = groundY - 18; // 躺倒后髋部高度
        const dy = targetY - person.y;
        person.vy += dy * 12 * dt; // 弹簧趋近
        person.vy *= Math.pow(0.22, dt); // 阻尼
      }
    }

    function stepPhase(dt){
      const phase = timeline[phaseIndex];
      phaseElapsed += dt;
      let t = Math.min(1, phaseElapsed / phase.d);

      if(phase.name === 'sway'){
        // 站立轻微左右摆动（-3° ~ 3°）
        person.rot = Math.sin(performance.now()/500) * 3;
      } else if(phase.name === 'tilt'){
        // 向前倾倒到 20°
        person.rot = lerp(0, 22, easeInOutCubic(t));
      } else if(phase.name === 'fall'){
        // 从 22° 到 90°，并向地面稍许位移
        person.rot = lerp(22, 90, easeInCubic(t));
        const targetHipY = groundY - 18; // 躺地的髋部高度
        person.y = lerp(groundY - 140, targetHipY, easeInCubic(t));
      } else if(phase.name === 'impact'){
        // 轻微闪烁
        // nothing; 由渲染做闪光
      } else if(phase.name === 'rest'){
        // 保持
        person.rot = 90;
      }

      if(phaseElapsed >= phase.d){
        phaseIndex = Math.min(timeline.length - 1, phaseIndex + 1);
        phaseElapsed = 0;
      }
    }

    function render(){
      clear();
      drawBackground();
      // impact 闪光效果
      if(timeline[phaseIndex]?.name === 'impact' && phaseElapsed < 0.15){
        const a = 0.6 * (1 - phaseElapsed/0.15);
        ctx.save();
        ctx.globalAlpha = a;
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,W,H);
        ctx.restore();
      }
      drawPerson(ctx, person.x, person.y, person.rot);

      // 提示文字
      ctx.save();
      ctx.font = '14px ui-sans-serif, system-ui';
      ctx.fillStyle = '#9bb1c5';
      ctx.fillText(`相位: ${timeline[phaseIndex].name}`, 16, 28);
      ctx.restore();
    }

    function raf(now){
      if(!running) { render(); return; }
      const dt = Math.min(0.033, (performance.now() - t0)/1000) * speed; // 限帧
      t0 = performance.now();
      stepPhase(dt);
      integrate(dt);
      render();
      requestAnimationFrame(raf);
    }

    // 初始化首帧
    resetModel();
    render();
  })();

  // ===================== 摇一摇动画（示意） =====================
  (function initShake(){
    const canvas = document.getElementById('shakeCanvas');
    const ctx = resizeForDPR(canvas);
    const W = canvas.clientWidth, H = canvas.clientHeight;

    let running = false, t0 = 0, sensitivity = 1.0, shakeCount = 0;
    const phone = { x: W/2, y: H/2, w: 180, h: 340, r: 28 };

    const playBtn = document.getElementById('playShake');
    const stopBtn = document.getElementById('stopShake');
    const sensInput = document.getElementById('shakeSensitivity');
    const sensVal = document.getElementById('shakeSensitivityVal');

    sensInput.addEventListener('input', () => { sensitivity = parseFloat(sensInput.value); sensVal.textContent = sensitivity.toFixed(1); });
    playBtn.addEventListener('click', ()=>{ running = true; t0 = performance.now(); raf(); });
    stopBtn.addEventListener('click', ()=>{ running = false; render(0); });

    function drawPhone(angle, offset){
      ctx.save();
      ctx.translate(phone.x + offset, phone.y);
      ctx.rotate(angle);
      // 机身
      roundRect(ctx, -phone.w/2, -phone.h/2, phone.w, phone.h, phone.r);
      ctx.fillStyle = '#182335';
      ctx.fill();
      ctx.strokeStyle = '#26364e'; ctx.lineWidth = 2; ctx.stroke();
      // 屏幕
      roundRect(ctx, -phone.w/2 + 12, -phone.h/2 + 18, phone.w - 24, phone.h - 46, 16);
      const grad = ctx.createLinearGradient(0, -phone.h/2, 0, phone.h/2);
      grad.addColorStop(0, '#0f1b2b'); grad.addColorStop(1, '#0a1320');
      ctx.fillStyle = grad; ctx.fill();
      // 提示条
      ctx.fillStyle = '#79ffe1';
      ctx.globalAlpha = 0.2 + 0.2*Math.random();
      ctx.fillRect(-phone.w/2 + 22, -8, phone.w - 44, 16);
      ctx.globalAlpha = 1;
      ctx.restore();

      // 计数
      ctx.save();
      ctx.font = '700 18px ui-sans-serif, system-ui';
      ctx.fillStyle = '#c5d6e8';
      ctx.fillText('摇动计数：' + shakeCount, 16, 28);
      ctx.restore();
    }

    function render(t){
      ctx.clearRect(0,0,W,H);
      // 轨迹线
      ctx.save();
      ctx.strokeStyle = '#1e2b3a'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(40, H/2); ctx.lineTo(W-40, H/2); ctx.stroke();
      ctx.restore();

      const wobble = Math.sin((t||0) * 3.2) * 0.12 * sensitivity; // 角度（弧度）
      const offset = Math.sin((t||0) * 6.4) * 28 * sensitivity;   // 水平位移
      drawPhone(wobble, offset);

      // 报警按钮提示
      const cx = W/2, cy = H*0.78, R = 44 + 2*Math.sin((t||0)*8);
      ctx.save();
      ctx.beginPath(); ctx.arc(cx, cy, R, 0, Math.PI*2);
      ctx.fillStyle = '#f72585'; ctx.globalAlpha = 0.12; ctx.fill(); ctx.globalAlpha = 1;
      ctx.beginPath(); ctx.arc(cx, cy, 38, 0, Math.PI*2);
      ctx.fillStyle = '#ff2d95'; ctx.fill();
      ctx.fillStyle = '#fff'; ctx.font = '700 16px ui-sans-serif, system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText('一键呼救', cx, cy);
      ctx.restore();
    }

    let dir = 1, lastSign = 0;
    function raf(){
      if(!running) return;
      const now = performance.now();
      const t = (now - t0)/1000;
      render(t);
      // 过零计数（模拟左右一次为1次）
      const s = Math.sign(Math.sin(t*6.4));
      if(s !== 0 && s !== lastSign){
        lastSign = s; dir *= -1; if(dir === 1) shakeCount++;
      }
      requestAnimationFrame(raf);
    }

    render(0);
  })();
  </script>
</body>
</html>
